{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/facets/CoreFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {LibDiamond} from \"../lib/LibDiamond.sol\";\n// import counter as we using their library\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {LibCoreFacet} from \"../lib/LibCoreFacet.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract CoreFacet {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    event GroupCreated(uint256 id, address creator);\n    event QuestCreated(LibCoreFacet.QuestData questData, uint256 id);\n    function createGroup(bytes32 name) external {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        ds.groupIds.increment();\n        ds.groupById[ds.groupIds.current()].name = name;\n        ds.groupById[ds.groupIds.current()].owner = msg.sender;\n        emit GroupCreated(ds.groupIds.current(), msg.sender);\n    }   \n\n    function addQuest(LibCoreFacet.QuestData memory _questData) external {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        // LibCoreFacet.enforceGroupOwner(_questData.groupId, msg.sender);\n        ds.questIds.increment();\n        ds.questById[ds.questIds.current()].name = _questData.name;\n        ds.questById[ds.questIds.current()].groupId = _questData.groupId;\n        ds.questById[ds.questIds.current()].engagePoints = _questData\n            .engagePoints;\n        emit QuestCreated(ds.questById[ds.questIds.current()], ds.questIds.current());\n    }\n\n    function modifyGroup(\n        uint256 _groupId,\n        bytes32 _newName,\n        address _newOwner\n    ) external {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        LibCoreFacet.enforceGroupOwner(_groupId, msg.sender);\n        ds.groupById[_groupId].name = _newName;\n        ds.groupById[_groupId].owner = _newOwner;\n    }\n\n    function completeQuest(uint256 _questId) external {\n        //todo use verification from polygon id\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        require(\n            ds.isCompletedByUser[_questId][msg.sender] == false,\n            \"user has already completed this quest\"\n        );\n        ds.isCompletedByUser[_questId][msg.sender] = true;\n        ds.userEngagePoints[ds.questById[_questId].groupId][msg.sender] += (\n            ds.questById[_questId].engagePoints\n        );\n    }\n\n    function getGroup(uint256 _groupId)\n        external\n        view\n        returns (LibCoreFacet.GroupData memory)\n    {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        return (ds.groupById[_groupId]);\n    }\n\n    function getQuest(uint256 _questId)\n        external\n        view\n        returns (LibCoreFacet.QuestData memory)\n    {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        return (ds.questById[_questId]);\n    }\n\n    function getUserEngagePoint(uint256 _groupId)\n        external\n        view\n        returns (uint256)\n    {\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\n        return (ds.userEngagePoints[_groupId][msg.sender]);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\ninterface IDiamond {\n    enum FacetCutAction {Add, Replace, Remove}\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\nimport { IDiamond } from \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {    \n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;    \n}\n"
    },
    "contracts/lib/LibCoreFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\nlibrary LibCoreFacet {\n    struct GroupData {\n        bytes32 name;\n        address owner;\n    }\n    struct QuestData {\n        bytes32 name;\n        uint256 groupId;\n        uint256 engagePoints;\n    }\n\n    using Counters for Counters.Counter;\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage.core\");\n    struct CoreState {\n        Counters.Counter groupIds;\n        Counters.Counter questIds; // PolygonId Requests are the same 1 to 1\n        mapping(uint256 => GroupData) groupById;\n        mapping(uint256 => QuestData) questById;\n        mapping(uint256 => mapping(address => bool)) isCompletedByUser; // with quest id\n        mapping(uint256 => mapping(address => uint256)) userEngagePoints;\n    }\n\n    function diamondStorage() internal pure returns (CoreState storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function enforceGroupOwner(uint256 _groupId, address _owner) internal view {\n        require(_groupId != 0, \"group id cannot be 0\");\n        require(_owner != address(0), \"owner address cannot be 0\");\n        require(\n            diamondStorage().groupById[_groupId].owner == _owner,\n            \"caller is not the owner of the group\"\n        );\n    }\n\n    function enforceOwnerOfQuest(uint256 _questId, address _owner)\n        internal\n        view\n    {\n        require(_owner != address(0), \"owner address cannot be 0\");\n        require(\n            diamondStorage()\n                .groupById[diamondStorage().questById[_questId].groupId]\n                .owner == _owner,\n            \"caller is not the owner of the group\"\n        );\n    }\n}\n"
    },
    "contracts/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\nimport {IDiamond} from \"../interfaces/IDiamond.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\nerror NoSelectorsGivenToAdd();\nerror NotContractOwner(address _user, address _contractOwner);\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\nerror IncorrectFacetCutAction(uint8 _action);\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\nerror CannotReplaceImmutableFunction(bytes4 _selector);\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(\n    bytes4 _selector\n);\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\nerror CannotRemoveImmutableFunction(bytes4 _selector);\nerror InitializationFunctionReverted(\n    address _initializationContractAddress,\n    bytes _calldata\n);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"droppinprotocol.com.diamond.storage\");\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\n        bytes4[] selectors;\n        mapping(bytes4 => bool) supportedInterfaces;\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n        }\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex]\n                .functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n            if (functionSelectors.length == 0) {\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\n            }\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add) {\n                addFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Replace) {\n                replaceFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Remove) {\n                removeFunctions(facetAddress, functionSelectors);\n            } else {\n                revert IncorrectFacetCutAction(uint8(action));\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_facetAddress == address(0)) {\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n        }\n        DiamondStorage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(ds.selectors.length);\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: Add facet has no code\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .facetAddressAndSelectorPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress != address(0)) {\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n            }\n            ds.facetAddressAndSelectorPosition[\n                    selector\n                ] = FacetAddressAndSelectorPosition(\n                _facetAddress,\n                selectorCount\n            );\n            ds.selectors.push(selector);\n            selectorCount++;\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        if (_facetAddress == address(0)) {\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(\n                _functionSelectors\n            );\n        }\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: Replace facet has no code\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .facetAddressAndSelectorPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress == address(this)) {\n                revert CannotReplaceImmutableFunction(selector);\n            }\n            if (oldFacetAddress == _facetAddress) {\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(\n                    selector\n                );\n            }\n            if (oldFacetAddress == address(0)) {\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\n            }\n            ds\n                .facetAddressAndSelectorPosition[selector]\n                .facetAddress = _facetAddress;\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        if (_facetAddress != address(0)) {\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            FacetAddressAndSelectorPosition\n                memory oldFacetAddressAndSelectorPosition = ds\n                    .facetAddressAndSelectorPosition[selector];\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\n            }\n\n            if (\n                oldFacetAddressAndSelectorPosition.facetAddress == address(this)\n            ) {\n                revert CannotRemoveImmutableFunction(selector);\n            }\n            selectorCount--;\n            if (\n                oldFacetAddressAndSelectorPosition.selectorPosition !=\n                selectorCount\n            ) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[\n                    oldFacetAddressAndSelectorPosition.selectorPosition\n                ] = lastSelector;\n                ds\n                    .facetAddressAndSelectorPosition[lastSelector]\n                    .selectorPosition = oldFacetAddressAndSelectorPosition\n                    .selectorPosition;\n            }\n            ds.selectors.pop();\n            delete ds.facetAddressAndSelectorPosition[selector];\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(\n            _init,\n            \"LibDiamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}