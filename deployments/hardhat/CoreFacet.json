{
  "address": "0xa9A605405144619e8229645FF4Ce1F53A74A69Bb",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_creator",
          "type": "address"
        }
      ],
      "name": "groupCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_groupId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "addQuest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "createGroup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_groupId",
          "type": "uint256"
        }
      ],
      "name": "getGroup",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            }
          ],
          "internalType": "struct GroupData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_questId",
          "type": "uint256"
        }
      ],
      "name": "getQuest",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "groupId",
              "type": "uint256"
            }
          ],
          "internalType": "struct QuestData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_groupId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_newName",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_newOwner",
          "type": "address"
        }
      ],
      "name": "modifyGroup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x65b9d7ff07f51eabf6f2bef97e591552b74cc9588f590ebe5109502936b69a77",
  "receipt": {
    "to": null,
    "from": "0x17BAd8cbCDeC350958dF0Bfe01E284dd8Fec3fcD",
    "contractAddress": "0xa9A605405144619e8229645FF4Ce1F53A74A69Bb",
    "transactionIndex": 0,
    "gasUsed": "334384",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5a431bb515c6f8893e221af6b490d798b8969bc79967456f64a738164bb7666f",
    "transactionHash": "0x65b9d7ff07f51eabf6f2bef97e591552b74cc9588f590ebe5109502936b69a77",
    "logs": [],
    "blockNumber": 6,
    "cumulativeGasUsed": "334384",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0b40c6a1768bc062321c5fbd53f899ac",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"groupCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_groupId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"addQuest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"createGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_groupId\",\"type\":\"uint256\"}],\"name\":\"getGroup\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct GroupData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_questId\",\"type\":\"uint256\"}],\"name\":\"getQuest\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"}],\"internalType\":\"struct QuestData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_groupId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_newName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"modifyGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/CoreFacet.sol\":\"CoreFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"contracts/facets/CoreFacet.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport { LibDiamond } from \\\"../lib/LibDiamond.sol\\\";\\n// import counter as we using their library\\nimport {Counters} from \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport {LibCoreFacet} from \\\"../lib/LibCoreFacet.sol\\\";\\n\\nstruct GroupData {\\n    bytes32 name;\\n    address owner;\\n}\\nstruct QuestData {\\n    bytes32 name;\\n    uint256 groupId;\\n} \\ncontract CoreFacet {\\n\\n    using Counters for Counters.Counter;\\n    event groupCreated(uint256 _id,address _creator);\\n    function createGroup(bytes32 name) external {\\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\\n        ds.groupIds.increment();\\n        ds.groupById[ds.groupIds.current()].name = name;\\n        ds.groupById[ds.groupIds.current()].owner = msg.sender;\\n    }\\n    function addQuest(uint256 _groupId, bytes32 name) external {\\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\\n        LibCoreFacet.enforceGroupOwner(_groupId, msg.sender);\\n        ds.questIds.increment();\\n        ds.questById[ds.questIds.current()].name = name;\\n        ds.questById[ds.questIds.current()].groupId = _groupId;\\n    }\\n    function modifyGroup(uint256 _groupId,bytes32 _newName, address _newOwner) external {\\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\\n        LibCoreFacet.enforceGroupOwner(_groupId,msg.sender);\\n        ds.groupById[_groupId].name = _newName;\\n        ds.groupById[_groupId].owner = _newOwner;\\n    }\\n    function getGroup(uint256 _groupId) external view returns (GroupData memory) {\\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\\n        return (GroupData(ds.groupById[_groupId].name, ds.groupById[_groupId].owner));\\n    }\\n    function getQuest(uint256 _questId) external view returns (QuestData memory) {\\n        LibCoreFacet.CoreState storage ds = LibCoreFacet.diamondStorage();\\n        return (QuestData(ds.questById[_questId].name, ds.questById[_questId].groupId));\\n    }\\n}\",\"keccak256\":\"0x3e6638cce33676552d099b12a83540e44d9fabeadffaa6b92f96064beb83a42f\"},\"contracts/interfaces/IDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\ninterface IDiamond {\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\",\"keccak256\":\"0x6413d0039db7a28616080690068c892a169fc3714f4fecedcc9a7a2257c5c70b\",\"license\":\"CC0-1.0\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\n\\ninterface IDiamondCut is IDiamond {    \\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;    \\n}\\n\",\"keccak256\":\"0xa5f3f20b9392a935c6b9ba56d542cc0cc7bdf7089e1b9d5a764af0546ce40226\",\"license\":\"CC0-1.0\"},\"contracts/lib/LibCoreFacet.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {Counters} from \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\nstruct GroupData {\\n    bytes32 name;\\n    address owner;\\n}\\nstruct QuestData {\\n    bytes32 name;\\n    uint256 groupId;\\n}\\nlibrary LibCoreFacet {\\n\\n    using Counters for Counters.Counter;\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage.core\\\");\\n    struct CoreState {\\n        Counters.Counter groupIds;\\n        Counters.Counter questIds; // PolygonId Requests are the same 1 to 1\\n        mapping(uint256 => GroupData) groupById;\\n        mapping(uint256 => QuestData) questById;\\n        mapping(uint256 => mapping(address => bool)) isCompletedByUser;\\n    }\\n\\n    function diamondStorage() internal pure returns (CoreState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n    function enforceGroupOwner(uint256 _groupId, address _owner) internal view {\\n        require(_groupId != 0, \\\"group id cannot be 0\\\");\\n        require(_owner != address(0), \\\"owner address cannot be 0\\\");\\n        require(diamondStorage().groupById[_groupId].owner == _owner, \\\"caller is not the owner of the group\\\");\\n    }\\n    function enforceOwnerOfQuest(uint256 _questId, address _owner ) internal view {\\n        require(_owner != address(0), \\\"owner address cannot be 0\\\");\\n        require(diamondStorage().groupById[diamondStorage().questById[_questId].groupId].owner == _owner,\\\"caller is not the owner of the group\\\");\\n    }\\n}\",\"keccak256\":\"0xc91617ffeed212f7cc988e730c4a7e8f0adc677396c2a42f988204dba2ad5892\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nerror NoSelectorsGivenToAdd();\\nerror NotContractOwner(address _user, address _contractOwner);\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\nerror IncorrectFacetCutAction(uint8 _action);\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"droppinprotocol.com.diamond.storage\\\");\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        if(msg.sender != diamondStorage().contractOwner) {\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\n        }        \\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\n            if(functionSelectors.length == 0) {\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\n            }\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamond.FacetCutAction.Add) {\\n                addFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\n                replaceFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\n                removeFunctions(facetAddress, functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction(uint8(action));\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        if(_facetAddress == address(0)) {\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);                \\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if(oldFacetAddress != address(0)) {\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\n            }            \\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        if(_facetAddress == address(0)) {\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\n        }\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if(oldFacetAddress == address(this)) {\\n                revert CannotReplaceImmutableFunction(selector);\\n            }\\n            if(oldFacetAddress == _facetAddress) {\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\n            }\\n            if(oldFacetAddress == address(0)) {\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\n            }\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        if(_facetAddress != address(0)) {\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\n        }        \\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\n            }\\n            \\n            \\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\n                revert CannotRemoveImmutableFunction(selector);\\n            }\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }        \\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if(contractSize == 0) {\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\n        }        \\n    }\\n}\\n\",\"keccak256\":\"0x00ca37a50c2f23cb278cb72e5a1209531f14ff7d275d8d373d9f32e4d3118650\",\"license\":\"CC0-1.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610516806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806349f86f341461005c5780635f249856146100ec57806379c4d03c146101015780638f12c19614610114578063ceb6065414610199575b600080fd5b6100cc61006a366004610460565b60408051808201825260008082526020918201819052825180840184528482527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90c80845293822080548252949091529181526001909201549181019190915290565b604080518251815260209283015192810192909252015b60405180910390f35b6100ff6100fa366004610479565b610236565b005b6100ff61010f36600461049b565b6102c3565b6100ff610122366004610460565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9098054600190810180835560009081527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b602052604080822094909455915482529190200180546001600160a01b03191633179055565b6102126101a7366004610460565b60408051808201825260008082526020918201819052825180840184528482527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b80845293822080548252949091529181526001909201546001600160a01b03169181019190915290565b60408051825181526020928301516001600160a01b031692810192909252016100e3565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9096102618333610323565b6102718160010180546001019055565b81816003016000610283846001015490565b815260200190815260200160002060000181905550828160030160006102aa846001015490565b8152602081019190915260400160002060010155505050565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9096102ee8433610323565b6000938452600201602052604090922090815560010180546001600160a01b0319166001600160a01b03909216919091179055565b8160000361036f5760405162461bcd60e51b8152602060048201526014602482015273067726f75702069642063616e6e6f7420626520360641b60448201526064015b60405180910390fd5b6001600160a01b0381166103c55760405162461bcd60e51b815260206004820152601960248201527f6f776e657220616464726573732063616e6e6f742062652030000000000000006044820152606401610366565b60008281527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b60205260409020600101546001600160a01b0382811691161461045c5760405162461bcd60e51b8152602060048201526024808201527f63616c6c6572206973206e6f7420746865206f776e6572206f662074686520676044820152630726f75760e41b6064820152608401610366565b5050565b60006020828403121561047257600080fd5b5035919050565b6000806040838503121561048c57600080fd5b50508035926020909101359150565b6000806000606084860312156104b057600080fd5b833592506020840135915060408401356001600160a01b03811681146104d557600080fd5b80915050925092509256fea26469706673582212205c79b8ced4b72ec8f8cc0efdfcfa2e1da8a7c3c37186afd1a21a0b590770979364736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806349f86f341461005c5780635f249856146100ec57806379c4d03c146101015780638f12c19614610114578063ceb6065414610199575b600080fd5b6100cc61006a366004610460565b60408051808201825260008082526020918201819052825180840184528482527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90c80845293822080548252949091529181526001909201549181019190915290565b604080518251815260209283015192810192909252015b60405180910390f35b6100ff6100fa366004610479565b610236565b005b6100ff61010f36600461049b565b6102c3565b6100ff610122366004610460565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9098054600190810180835560009081527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b602052604080822094909455915482529190200180546001600160a01b03191633179055565b6102126101a7366004610460565b60408051808201825260008082526020918201819052825180840184528482527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b80845293822080548252949091529181526001909201546001600160a01b03169181019190915290565b60408051825181526020928301516001600160a01b031692810192909252016100e3565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9096102618333610323565b6102718160010180546001019055565b81816003016000610283846001015490565b815260200190815260200160002060000181905550828160030160006102aa846001015490565b8152602081019190915260400160002060010155505050565b7f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a9096102ee8433610323565b6000938452600201602052604090922090815560010180546001600160a01b0319166001600160a01b03909216919091179055565b8160000361036f5760405162461bcd60e51b8152602060048201526014602482015273067726f75702069642063616e6e6f7420626520360641b60448201526064015b60405180910390fd5b6001600160a01b0381166103c55760405162461bcd60e51b815260206004820152601960248201527f6f776e657220616464726573732063616e6e6f742062652030000000000000006044820152606401610366565b60008281527f7c7557f95a2f97ba23b20056e448af54f71e639e66ae0b4d106fd6235e42a90b60205260409020600101546001600160a01b0382811691161461045c5760405162461bcd60e51b8152602060048201526024808201527f63616c6c6572206973206e6f7420746865206f776e6572206f662074686520676044820152630726f75760e41b6064820152608401610366565b5050565b60006020828403121561047257600080fd5b5035919050565b6000806040838503121561048c57600080fd5b50508035926020909101359150565b6000806000606084860312156104b057600080fd5b833592506020840135915060408401356001600160a01b03811681146104d557600080fd5b80915050925092509256fea26469706673582212205c79b8ced4b72ec8f8cc0efdfcfa2e1da8a7c3c37186afd1a21a0b590770979364736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}